# 基本情報技術者試験　アルゴリズム

##　データ構造
###　リスト
データとデータを数珠繋ぎにして管理する構造。リストが扱うデータには<u>ポインタ</u>と呼ばれる番号が付属される。
ポインタはメモリ上の位置を表す番号。ポインタを書き換えることでデータの追加や挿入・削除が行える。新しいデータへのポインタを書くと<u>挿入</u>、一つ後ろのポインタを書き込むと<u>削除</u>になる。
ただし、リストはポインタ順に辿らないといけないため、配列のように添字を使用して任意のデータに直接アクセスすることはできない。
ポインタの持ち方には以下の3種類がある。

#### 単方向リスト
次のデータへのポインタを持つリスト。ただし、一方通行なので先頭のデータから辿っていく必要がある。

#### 双方向リスト
次のデータへのポインタと、前データへのポインタを持つリスト。前後どちらにもデータを辿っていくことができる。

#### 循環リスト
次のデータへのポインタを持つリスト。ただし、最後尾のデータは先頭データのポインタをもつ。よって循環して辿っていくことになる。

###　キュー
待ち行列。FIFO（First In First Out）先入先出。実例としてGUIプログラムの動作やプリンタの印刷キュー。

###　スタック
積み上げ行列。LIFO(Last In First Out)後入先出。実例としてプログラムが呼び出したサブルーチンから元の処理に戻れる仕組み。

##　木構造
階層構造を持つデータで広く用いられるデータ構造。HDDなどのファイルシステムやドメイン名などの管理に使用されている。
データを分岐した節点を辿ることで目的のデータに到達できる。
最上位の節点が「根（ルート）」、そこから「枝（ブランチ）」が伸びて各節点を繋ぎながら末端の「葉（リーフ）」に辿り着く。
葉以外の全ての節が二つの子を持ち、根から葉までの深さが等しい二分木を<u>完全二分木</u>という。

#### 二分木探索
親に対する左分木と右分木の関係が`左の子 ＜ 親 ＜ 右の子`となる探索法のこと。二分木探索法ではデータの探索が容易に行うことができる。

## 探索アルゴリズム
探索アルゴリズムとは複数あるデータ群から目的のデータを探し出すアルゴリズムのこと。

[参考ページ](https://breezegroup.co.jp/202006/algorithm-search/)

### 線形探索法（リニアサーチ）
探索対象のデータ群の先頭から順に値を比較していく方法。データ群が整列していなくても探索できるが、使用頻度が高い順に整列されていると少ない回数で目的のデータを探索することが可能。

```math
平均比較回数：(N+1)/2\\
最大比較回数:N
```

@import "./img/線形探索法-1.png" { width=80% title="線形探索法"}

### 2分探索法（バイナリサーチ）
探索データが昇順または降順に整列されている時に用いる方法。データ中央値と探索対象のデータを比較し、その代償により探索範囲を1/2ずつ狭めていくことで線形探索と比べて効率よく探索できることが可能。

```math
平均比較回数:\log_2 N \\
最大比較回数：\log_2 N + 1
```

@import "./img/2分探索法-1.png" { width=80% title="2分探索法"}

### ハッシュ探索法
ハッシュ関数を用いてデータの格納位置を参照する探索方法。ただしデータ格納時に同じハッシュ関数を用いた計算式で求める位置へと格納されている必要がある。


例：5桁の数a1,a2,a3,a4,a5を`mod(a1+a2+a3+a4+a5,20)`というハッシュ関数を用いて位置が決められ格納されているとする。※modは余りを求める関数

@import "./img/ハッシュ探索法-1.png" { width=95% title="ハッシュ探索法"}

データ値「13579」のハッシュ値を探索するハッシュ関数
```math
mod(1+3+5+7+9,20)\\
=mod(25,20)=5
```
ハッシュ値がデータ値「13579」の格納位置になる。

探索対象の格納位置をピンポイントで参照する方法なので圧倒的に小さい計算量で探索を行える。
ただし前提として格納時にハッシュ関数を用いた計算式で格納されている必要がある。また格納位置が同じになってしまう計算式が他にあると、衝突（シノニム）が発生してしまうので結果が重複しないようなハッシュ関数で格納されている必要がある。
